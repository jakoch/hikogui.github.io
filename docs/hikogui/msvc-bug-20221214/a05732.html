<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HikoGUI: hi::v1::lean_vector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="version_dropdown.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HikoGUI
   </div>
   <div id="projectbrief">A low latency retained GUI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="a02400.html">hi</a></li><li class="navelem"><a class="el" href="a02401.html">v1</a></li><li class="navelem"><a class="el" href="a05732.html">lean_vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">hi::v1::lean_vector&lt; T &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="a02156_source.html">hikogui/lean_vector.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ca9bff19d578d079c8c1243098f8569" id="r_a8ca9bff19d578d079c8c1243098f8569"><td class="memItemLeft" align="right" valign="top"><a id="a8ca9bff19d578d079c8c1243098f8569" name="a8ca9bff19d578d079c8c1243098f8569"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = T</td></tr>
<tr class="separator:a8ca9bff19d578d079c8c1243098f8569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf398850cda773ddf1f733f0077a6ac" id="r_adcf398850cda773ddf1f733f0077a6ac"><td class="memItemLeft" align="right" valign="top"><a id="adcf398850cda773ddf1f733f0077a6ac" name="adcf398850cda773ddf1f733f0077a6ac"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = value_type *</td></tr>
<tr class="separator:adcf398850cda773ddf1f733f0077a6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c6f348448d66e314f6ef8e3ab477b0" id="r_a49c6f348448d66e314f6ef8e3ab477b0"><td class="memItemLeft" align="right" valign="top"><a id="a49c6f348448d66e314f6ef8e3ab477b0" name="a49c6f348448d66e314f6ef8e3ab477b0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = value_type const *</td></tr>
<tr class="separator:a49c6f348448d66e314f6ef8e3ab477b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f10e1070bb2308c272e6c9ed784217" id="r_a57f10e1070bb2308c272e6c9ed784217"><td class="memItemLeft" align="right" valign="top"><a id="a57f10e1070bb2308c272e6c9ed784217" name="a57f10e1070bb2308c272e6c9ed784217"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type &amp;</td></tr>
<tr class="separator:a57f10e1070bb2308c272e6c9ed784217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb95607b3812b1601124a07c025af4b" id="r_a3cb95607b3812b1601124a07c025af4b"><td class="memItemLeft" align="right" valign="top"><a id="a3cb95607b3812b1601124a07c025af4b" name="a3cb95607b3812b1601124a07c025af4b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = value_type const  &amp;</td></tr>
<tr class="separator:a3cb95607b3812b1601124a07c025af4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dac72d5a504d1d56bdc5850f49d090" id="r_a98dac72d5a504d1d56bdc5850f49d090"><td class="memItemLeft" align="right" valign="top"><a id="a98dac72d5a504d1d56bdc5850f49d090" name="a98dac72d5a504d1d56bdc5850f49d090"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = value_type *</td></tr>
<tr class="separator:a98dac72d5a504d1d56bdc5850f49d090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362e65dc8301ea3cb47fc794f50a649b" id="r_a362e65dc8301ea3cb47fc794f50a649b"><td class="memItemLeft" align="right" valign="top"><a id="a362e65dc8301ea3cb47fc794f50a649b" name="a362e65dc8301ea3cb47fc794f50a649b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = value_type const *</td></tr>
<tr class="separator:a362e65dc8301ea3cb47fc794f50a649b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9116c7dc6a2fd272e25987ee66e3f98" id="r_aa9116c7dc6a2fd272e25987ee66e3f98"><td class="memItemLeft" align="right" valign="top"><a id="aa9116c7dc6a2fd272e25987ee66e3f98" name="aa9116c7dc6a2fd272e25987ee66e3f98"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator.html">std::reverse_iterator</a>&lt; iterator &gt;</td></tr>
<tr class="separator:aa9116c7dc6a2fd272e25987ee66e3f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5621e133f147a27447922dfc88e2d308" id="r_a5621e133f147a27447922dfc88e2d308"><td class="memItemLeft" align="right" valign="top"><a id="a5621e133f147a27447922dfc88e2d308" name="a5621e133f147a27447922dfc88e2d308"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/iterator/reverse_iterator.html">std::reverse_iterator</a>&lt; const_iterator &gt;</td></tr>
<tr class="separator:a5621e133f147a27447922dfc88e2d308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae356503c5891ba7918f4f72839992412" id="r_ae356503c5891ba7918f4f72839992412"><td class="memItemLeft" align="right" valign="top"><a id="ae356503c5891ba7918f4f72839992412" name="ae356503c5891ba7918f4f72839992412"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a></td></tr>
<tr class="separator:ae356503c5891ba7918f4f72839992412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62edaf12a2b573f3f04b25a809a3aa8b" id="r_a62edaf12a2b573f3f04b25a809a3aa8b"><td class="memItemLeft" align="right" valign="top"><a id="a62edaf12a2b573f3f04b25a809a3aa8b" name="a62edaf12a2b573f3f04b25a809a3aa8b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/types/ptrdiff_t.html">std::ptrdiff_t</a></td></tr>
<tr class="separator:a62edaf12a2b573f3f04b25a809a3aa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60ae588979969d747ba49a010d910c9" id="r_aa60ae588979969d747ba49a010d910c9"><td class="memItemLeft" align="right" valign="top"><a id="aa60ae588979969d747ba49a010d910c9" name="aa60ae588979969d747ba49a010d910c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/allocator.html">std::allocator</a>&lt; value_type &gt;</td></tr>
<tr class="separator:aa60ae588979969d747ba49a010d910c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae11d1455952e63ca2885784acbea6ccc" id="r_ae11d1455952e63ca2885784acbea6ccc"><td class="memItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/allocator.html">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#ae11d1455952e63ca2885784acbea6ccc">get_allocator</a> () const noexcept</td></tr>
<tr class="memdesc:ae11d1455952e63ca2885784acbea6ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator_type used to allocate items.  <br /></td></tr>
<tr class="separator:ae11d1455952e63ca2885784acbea6ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4bd3e52876efbd6d0f0213a97f2ed5" id="r_a9d4bd3e52876efbd6d0f0213a97f2ed5"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a9d4bd3e52876efbd6d0f0213a97f2ed5">lean_vector</a> () noexcept=default</td></tr>
<tr class="memdesc:a9d4bd3e52876efbd6d0f0213a97f2ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an empty vector.  <br /></td></tr>
<tr class="separator:a9d4bd3e52876efbd6d0f0213a97f2ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ba6c80fb09eee162418a255cb416de" id="r_ad1ba6c80fb09eee162418a255cb416de"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#ad1ba6c80fb09eee162418a255cb416de">~lean_vector</a> ()</td></tr>
<tr class="memdesc:ad1ba6c80fb09eee162418a255cb416de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct the vector.  <br /></td></tr>
<tr class="separator:ad1ba6c80fb09eee162418a255cb416de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009483910d8dda316d0b17f92f4127ff" id="r_a009483910d8dda316d0b17f92f4127ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a009483910d8dda316d0b17f92f4127ff">lean_vector</a> (<a class="el" href="a05732.html">lean_vector</a> const &amp;<a class="el" href="a02388.html#gga5072420515fa5218d0dbf4a2f3202120a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>)</td></tr>
<tr class="memdesc:a009483910d8dda316d0b17f92f4127ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-construct a vector.  <br /></td></tr>
<tr class="separator:a009483910d8dda316d0b17f92f4127ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fbeb35713e1181c14ac7e6f65fe4ac4" id="r_a8fbeb35713e1181c14ac7e6f65fe4ac4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a8fbeb35713e1181c14ac7e6f65fe4ac4">lean_vector</a> (<a class="el" href="a05732.html">lean_vector</a> &amp;&amp;<a class="el" href="a02388.html#gga5072420515fa5218d0dbf4a2f3202120a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a8fbeb35713e1181c14ac7e6f65fe4ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-construct a vector.  <br /></td></tr>
<tr class="separator:a8fbeb35713e1181c14ac7e6f65fe4ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf141f4612b911b62e52aee94683b27e" id="r_aaf141f4612b911b62e52aee94683b27e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05732.html">lean_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#aaf141f4612b911b62e52aee94683b27e">operator=</a> (<a class="el" href="a05732.html">lean_vector</a> const &amp;<a class="el" href="a02388.html#gga5072420515fa5218d0dbf4a2f3202120a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:aaf141f4612b911b62e52aee94683b27e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assign a vector.  <br /></td></tr>
<tr class="separator:aaf141f4612b911b62e52aee94683b27e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfb3869e08382c52785b2c28fcb461e" id="r_a1bfb3869e08382c52785b2c28fcb461e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="a05732.html">lean_vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a1bfb3869e08382c52785b2c28fcb461e">operator=</a> (<a class="el" href="a05732.html">lean_vector</a> &amp;&amp;<a class="el" href="a02388.html#gga5072420515fa5218d0dbf4a2f3202120a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="memdesc:a1bfb3869e08382c52785b2c28fcb461e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign a vector.  <br /></td></tr>
<tr class="separator:a1bfb3869e08382c52785b2c28fcb461e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d9828415c6b384da78d003d130353f" id="r_a23d9828415c6b384da78d003d130353f"><td class="memItemLeft" align="right" valign="top"><a id="a23d9828415c6b384da78d003d130353f" name="a23d9828415c6b384da78d003d130353f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a05732.html">lean_vector</a> &amp;<a class="el" href="a02388.html#gga5072420515fa5218d0dbf4a2f3202120a795f3202b17cb6bc3d4b771d8c6c9eaf">other</a>) noexcept</td></tr>
<tr class="separator:a23d9828415c6b384da78d003d130353f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee190da89152fd2e9efe0bc19b33b4a" id="r_aeee190da89152fd2e9efe0bc19b33b4a"><td class="memItemLeft" align="right" valign="top"><a id="aeee190da89152fd2e9efe0bc19b33b4a" name="aeee190da89152fd2e9efe0bc19b33b4a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>lean_vector</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> count)</td></tr>
<tr class="separator:aeee190da89152fd2e9efe0bc19b33b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71806110c2a3b0a1460e32ab5164855f" id="r_a71806110c2a3b0a1460e32ab5164855f"><td class="memItemLeft" align="right" valign="top"><a id="a71806110c2a3b0a1460e32ab5164855f" name="a71806110c2a3b0a1460e32ab5164855f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>lean_vector</b> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> count, value_type const &amp;value)</td></tr>
<tr class="separator:a71806110c2a3b0a1460e32ab5164855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8739df04d292d9ac37d0116f820619b" id="r_ae8739df04d292d9ac37d0116f820619b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#ae8739df04d292d9ac37d0116f820619b">lean_vector</a> (std::input_iterator auto first, std::input_iterator auto last)</td></tr>
<tr class="memdesc:ae8739df04d292d9ac37d0116f820619b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the data pointed by iterators.  <br /></td></tr>
<tr class="separator:ae8739df04d292d9ac37d0116f820619b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b2346f101b5f2e30562b18db7d8777" id="r_a52b2346f101b5f2e30562b18db7d8777"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a52b2346f101b5f2e30562b18db7d8777">lean_vector</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type &gt; list)</td></tr>
<tr class="memdesc:a52b2346f101b5f2e30562b18db7d8777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a vector with the given initializer list.  <br /></td></tr>
<tr class="separator:a52b2346f101b5f2e30562b18db7d8777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e293c1f9ddadee630358442fba4562" id="r_af3e293c1f9ddadee630358442fba4562"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#af3e293c1f9ddadee630358442fba4562">assign</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> count, value_type const &amp;value)</td></tr>
<tr class="memdesc:af3e293c1f9ddadee630358442fba4562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the data in the vector.  <br /></td></tr>
<tr class="separator:af3e293c1f9ddadee630358442fba4562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9533289ab93373e885b423c1ae8d6d20" id="r_a9533289ab93373e885b423c1ae8d6d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a9533289ab93373e885b423c1ae8d6d20">assign</a> (std::input_iterator auto first, std::input_iterator auto last)</td></tr>
<tr class="memdesc:a9533289ab93373e885b423c1ae8d6d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the data in the vector.  <br /></td></tr>
<tr class="separator:a9533289ab93373e885b423c1ae8d6d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc44e4ca9701edbcd442fa02fed6905" id="r_a8bc44e4ca9701edbcd442fa02fed6905"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a8bc44e4ca9701edbcd442fa02fed6905">assign</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type &gt; list)</td></tr>
<tr class="memdesc:a8bc44e4ca9701edbcd442fa02fed6905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the data in the vector.  <br /></td></tr>
<tr class="separator:a8bc44e4ca9701edbcd442fa02fed6905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7556b20196154e44ff8f4e9774b68235" id="r_a7556b20196154e44ff8f4e9774b68235"><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a7556b20196154e44ff8f4e9774b68235">data</a> () noexcept</td></tr>
<tr class="memdesc:a7556b20196154e44ff8f4e9774b68235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the first item.  <br /></td></tr>
<tr class="separator:a7556b20196154e44ff8f4e9774b68235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7056fc833183b037a15f17bfec418088" id="r_a7056fc833183b037a15f17bfec418088"><td class="memItemLeft" align="right" valign="top">const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a7056fc833183b037a15f17bfec418088">data</a> () const noexcept</td></tr>
<tr class="memdesc:a7056fc833183b037a15f17bfec418088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const-pointer to the first item.  <br /></td></tr>
<tr class="separator:a7056fc833183b037a15f17bfec418088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8200c05b6649e8b413066a5b7ff9b358" id="r_a8200c05b6649e8b413066a5b7ff9b358"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a8200c05b6649e8b413066a5b7ff9b358">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a8200c05b6649e8b413066a5b7ff9b358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the vector is empty.  <br /></td></tr>
<tr class="separator:a8200c05b6649e8b413066a5b7ff9b358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc78141ebcf5b628c213a15265d3dc4" id="r_a9fc78141ebcf5b628c213a15265d3dc4"><td class="memItemLeft" align="right" valign="top">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a9fc78141ebcf5b628c213a15265d3dc4">size</a> () const noexcept</td></tr>
<tr class="memdesc:a9fc78141ebcf5b628c213a15265d3dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items in the vector.  <br /></td></tr>
<tr class="separator:a9fc78141ebcf5b628c213a15265d3dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbb9fbd0e87b28c436aad64d97f71d9" id="r_abfbb9fbd0e87b28c436aad64d97f71d9"><td class="memItemLeft" align="right" valign="top"><a id="abfbb9fbd0e87b28c436aad64d97f71d9" name="abfbb9fbd0e87b28c436aad64d97f71d9"></a>
constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><b>max_size</b> () const noexcept</td></tr>
<tr class="separator:abfbb9fbd0e87b28c436aad64d97f71d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e0ab5070a807687b4fae0bcdb6f2e99" id="r_a4e0ab5070a807687b4fae0bcdb6f2e99"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a4e0ab5070a807687b4fae0bcdb6f2e99">short_capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a4e0ab5070a807687b4fae0bcdb6f2e99"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum number of items that can fit without allocation.  <br /></td></tr>
<tr class="separator:a4e0ab5070a807687b4fae0bcdb6f2e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1145298f9e2f8ae3767e2ccf7d60064f" id="r_a1145298f9e2f8ae3767e2ccf7d60064f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a1145298f9e2f8ae3767e2ccf7d60064f">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a1145298f9e2f8ae3767e2ccf7d60064f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current capacity of the vector.  <br /></td></tr>
<tr class="separator:a1145298f9e2f8ae3767e2ccf7d60064f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de7d5484cc1cf92681a2d8daf8c8732" id="r_a9de7d5484cc1cf92681a2d8daf8c8732"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a9de7d5484cc1cf92681a2d8daf8c8732">at</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> index)</td></tr>
<tr class="memdesc:a9de7d5484cc1cf92681a2d8daf8c8732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an item in the vector.  <br /></td></tr>
<tr class="separator:a9de7d5484cc1cf92681a2d8daf8c8732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1e6bd9c0a6f4bbbedb40ddb2448674" id="r_aaf1e6bd9c0a6f4bbbedb40ddb2448674"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#aaf1e6bd9c0a6f4bbbedb40ddb2448674">at</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> index) const</td></tr>
<tr class="memdesc:aaf1e6bd9c0a6f4bbbedb40ddb2448674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const-reference to an item in the vector.  <br /></td></tr>
<tr class="separator:aaf1e6bd9c0a6f4bbbedb40ddb2448674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d205d7ee1752a2556c3b2e09caee78" id="r_af5d205d7ee1752a2556c3b2e09caee78"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#af5d205d7ee1752a2556c3b2e09caee78">operator[]</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> index) noexcept</td></tr>
<tr class="memdesc:af5d205d7ee1752a2556c3b2e09caee78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to an item in the vector.  <br /></td></tr>
<tr class="separator:af5d205d7ee1752a2556c3b2e09caee78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b10ca7e1bc4fb38d57d30a1157a8a87" id="r_a9b10ca7e1bc4fb38d57d30a1157a8a87"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a9b10ca7e1bc4fb38d57d30a1157a8a87">operator[]</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> index) const noexcept</td></tr>
<tr class="memdesc:a9b10ca7e1bc4fb38d57d30a1157a8a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const-reference to an item in the vector.  <br /></td></tr>
<tr class="separator:a9b10ca7e1bc4fb38d57d30a1157a8a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90888a049750ffd14d42525571423a5" id="r_ab90888a049750ffd14d42525571423a5"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#ab90888a049750ffd14d42525571423a5">front</a> () noexcept</td></tr>
<tr class="memdesc:ab90888a049750ffd14d42525571423a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the first item in the vector.  <br /></td></tr>
<tr class="separator:ab90888a049750ffd14d42525571423a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd16d4a058ac76a96440e72cb21050f" id="r_a0bd16d4a058ac76a96440e72cb21050f"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a0bd16d4a058ac76a96440e72cb21050f">front</a> () const noexcept</td></tr>
<tr class="memdesc:a0bd16d4a058ac76a96440e72cb21050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const-reference to the first item in the vector.  <br /></td></tr>
<tr class="separator:a0bd16d4a058ac76a96440e72cb21050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162316a870010766a3bbbed0b321b3e5" id="r_a162316a870010766a3bbbed0b321b3e5"><td class="memItemLeft" align="right" valign="top">reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a162316a870010766a3bbbed0b321b3e5">back</a> () noexcept</td></tr>
<tr class="memdesc:a162316a870010766a3bbbed0b321b3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the last item in the vector.  <br /></td></tr>
<tr class="separator:a162316a870010766a3bbbed0b321b3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5abe4f4cfa1d5f4384cf690a55e920d" id="r_ac5abe4f4cfa1d5f4384cf690a55e920d"><td class="memItemLeft" align="right" valign="top">const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#ac5abe4f4cfa1d5f4384cf690a55e920d">back</a> () const noexcept</td></tr>
<tr class="memdesc:ac5abe4f4cfa1d5f4384cf690a55e920d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const-reference to the last item in the vector.  <br /></td></tr>
<tr class="separator:ac5abe4f4cfa1d5f4384cf690a55e920d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b04cdb9a5a5bd228934e8a5977c4f7" id="r_a57b04cdb9a5a5bd228934e8a5977c4f7"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a57b04cdb9a5a5bd228934e8a5977c4f7">begin</a> () noexcept</td></tr>
<tr class="memdesc:a57b04cdb9a5a5bd228934e8a5977c4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator to the first item in the vector.  <br /></td></tr>
<tr class="separator:a57b04cdb9a5a5bd228934e8a5977c4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91046ba0f53158a092849d2607dcfa2c" id="r_a91046ba0f53158a092849d2607dcfa2c"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a91046ba0f53158a092849d2607dcfa2c">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a91046ba0f53158a092849d2607dcfa2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an const-iterator to the first item in the vector.  <br /></td></tr>
<tr class="separator:a91046ba0f53158a092849d2607dcfa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932390a29bfade9db62d5350a8c8a2b9" id="r_a932390a29bfade9db62d5350a8c8a2b9"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a932390a29bfade9db62d5350a8c8a2b9">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a932390a29bfade9db62d5350a8c8a2b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an const-iterator to the first item in the vector.  <br /></td></tr>
<tr class="separator:a932390a29bfade9db62d5350a8c8a2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cadc35ba47cac083c39cd3b0ccd617" id="r_a52cadc35ba47cac083c39cd3b0ccd617"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a52cadc35ba47cac083c39cd3b0ccd617">end</a> () noexcept</td></tr>
<tr class="memdesc:a52cadc35ba47cac083c39cd3b0ccd617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator beyond the last item in the vector.  <br /></td></tr>
<tr class="separator:a52cadc35ba47cac083c39cd3b0ccd617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1018af99861e880ca1ab793b5e3e8e" id="r_a1b1018af99861e880ca1ab793b5e3e8e"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a1b1018af99861e880ca1ab793b5e3e8e">end</a> () const noexcept</td></tr>
<tr class="memdesc:a1b1018af99861e880ca1ab793b5e3e8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an const-iterator beyond the last item in the vector.  <br /></td></tr>
<tr class="separator:a1b1018af99861e880ca1ab793b5e3e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5759d8eee327cc5da171017f238c68ee" id="r_a5759d8eee327cc5da171017f238c68ee"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a5759d8eee327cc5da171017f238c68ee">cend</a> () const noexcept</td></tr>
<tr class="memdesc:a5759d8eee327cc5da171017f238c68ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an const-iterator beyond the last item in the vector.  <br /></td></tr>
<tr class="separator:a5759d8eee327cc5da171017f238c68ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dd53d32c855772af42cf88e3722b7e9" id="r_a2dd53d32c855772af42cf88e3722b7e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a2dd53d32c855772af42cf88e3722b7e9">clear</a> () noexcept</td></tr>
<tr class="memdesc:a2dd53d32c855772af42cf88e3722b7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all items from the vector.  <br /></td></tr>
<tr class="separator:a2dd53d32c855772af42cf88e3722b7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7299d1c263daa1e7e9d65af6762187" id="r_afb7299d1c263daa1e7e9d65af6762187"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#afb7299d1c263daa1e7e9d65af6762187">reserve</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> new_capacity)</td></tr>
<tr class="memdesc:afb7299d1c263daa1e7e9d65af6762187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve capacity for items.  <br /></td></tr>
<tr class="separator:afb7299d1c263daa1e7e9d65af6762187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32620dff1ab4a3eef6c0c54b8afcdea" id="r_aa32620dff1ab4a3eef6c0c54b8afcdea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#aa32620dff1ab4a3eef6c0c54b8afcdea">shrink_to_fit</a> ()</td></tr>
<tr class="memdesc:aa32620dff1ab4a3eef6c0c54b8afcdea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink the allocation to fit the current number of items.  <br /></td></tr>
<tr class="separator:aa32620dff1ab4a3eef6c0c54b8afcdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe97ac3c8c359b71eaabdb7f1bca9619" id="r_abe97ac3c8c359b71eaabdb7f1bca9619"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abe97ac3c8c359b71eaabdb7f1bca9619"><td class="memTemplItemLeft" align="right" valign="top">iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05732.html#abe97ac3c8c359b71eaabdb7f1bca9619">emplace</a> (const_iterator pos, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:abe97ac3c8c359b71eaabdb7f1bca9619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct in-place a new item.  <br /></td></tr>
<tr class="separator:abe97ac3c8c359b71eaabdb7f1bca9619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb98e17fd016135d7903a583b41e7497" id="r_afb98e17fd016135d7903a583b41e7497"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#afb98e17fd016135d7903a583b41e7497">insert</a> (const_iterator pos, value_type const &amp;value)</td></tr>
<tr class="memdesc:afb98e17fd016135d7903a583b41e7497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new item.  <br /></td></tr>
<tr class="separator:afb98e17fd016135d7903a583b41e7497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b8bf2387a41b4dc1d1ad57e61e7f34" id="r_a84b8bf2387a41b4dc1d1ad57e61e7f34"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a84b8bf2387a41b4dc1d1ad57e61e7f34">insert</a> (const_iterator pos, value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a84b8bf2387a41b4dc1d1ad57e61e7f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new item.  <br /></td></tr>
<tr class="separator:a84b8bf2387a41b4dc1d1ad57e61e7f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9593ec98a4aa649967982956e76febc6" id="r_a9593ec98a4aa649967982956e76febc6"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a9593ec98a4aa649967982956e76febc6">insert</a> (const_iterator pos, <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> count, value_type const &amp;value)</td></tr>
<tr class="memdesc:a9593ec98a4aa649967982956e76febc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new item.  <br /></td></tr>
<tr class="separator:a9593ec98a4aa649967982956e76febc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0114401f50630793f465463b37e375aa" id="r_a0114401f50630793f465463b37e375aa"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a0114401f50630793f465463b37e375aa">insert</a> (const_iterator pos, std::input_iterator auto first, std::input_iterator auto last)</td></tr>
<tr class="memdesc:a0114401f50630793f465463b37e375aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new items.  <br /></td></tr>
<tr class="separator:a0114401f50630793f465463b37e375aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5876ab74d01fa1d04effcec8204a707d" id="r_a5876ab74d01fa1d04effcec8204a707d"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a5876ab74d01fa1d04effcec8204a707d">insert</a> (const_iterator pos, <a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type &gt; list)</td></tr>
<tr class="memdesc:a5876ab74d01fa1d04effcec8204a707d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert new items.  <br /></td></tr>
<tr class="separator:a5876ab74d01fa1d04effcec8204a707d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eeee9f15b3b6bc1db6b88528c87b757" id="r_a5eeee9f15b3b6bc1db6b88528c87b757"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a5eeee9f15b3b6bc1db6b88528c87b757">erase</a> (const_iterator pos)</td></tr>
<tr class="memdesc:a5eeee9f15b3b6bc1db6b88528c87b757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an item at position.  <br /></td></tr>
<tr class="separator:a5eeee9f15b3b6bc1db6b88528c87b757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0183d874ede6d9768580bfc5b0d43b" id="r_afb0183d874ede6d9768580bfc5b0d43b"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#afb0183d874ede6d9768580bfc5b0d43b">erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr class="memdesc:afb0183d874ede6d9768580bfc5b0d43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase an items.  <br /></td></tr>
<tr class="separator:afb0183d874ede6d9768580bfc5b0d43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1e54b49f44c6d442d4880425ae68b1" id="r_a6b1e54b49f44c6d442d4880425ae68b1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a6b1e54b49f44c6d442d4880425ae68b1"><td class="memTemplItemLeft" align="right" valign="top">reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05732.html#a6b1e54b49f44c6d442d4880425ae68b1">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a6b1e54b49f44c6d442d4880425ae68b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place construct an item at the end of the vector.  <br /></td></tr>
<tr class="separator:a6b1e54b49f44c6d442d4880425ae68b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fafda4b07aab202d15218ee0288774d" id="r_a2fafda4b07aab202d15218ee0288774d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a2fafda4b07aab202d15218ee0288774d">push_back</a> (value_type const &amp;value)</td></tr>
<tr class="memdesc:a2fafda4b07aab202d15218ee0288774d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an item to the end of the vector.  <br /></td></tr>
<tr class="separator:a2fafda4b07aab202d15218ee0288774d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1645f5b2d3e045b6fbb1154398f0ebc2" id="r_a1645f5b2d3e045b6fbb1154398f0ebc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a1645f5b2d3e045b6fbb1154398f0ebc2">push_back</a> (value_type &amp;&amp;value)</td></tr>
<tr class="memdesc:a1645f5b2d3e045b6fbb1154398f0ebc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move an item to the end of the vector.  <br /></td></tr>
<tr class="separator:a1645f5b2d3e045b6fbb1154398f0ebc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8683ca629dbf6340ccf6275ec7b2c5c" id="r_aa8683ca629dbf6340ccf6275ec7b2c5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#aa8683ca629dbf6340ccf6275ec7b2c5c">pop_back</a> ()</td></tr>
<tr class="memdesc:aa8683ca629dbf6340ccf6275ec7b2c5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the last item from the vector.  <br /></td></tr>
<tr class="separator:aa8683ca629dbf6340ccf6275ec7b2c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733442172fe13212fafcba751d84fa0a" id="r_a733442172fe13212fafcba751d84fa0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a733442172fe13212fafcba751d84fa0a">resize</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> new_size)</td></tr>
<tr class="memdesc:a733442172fe13212fafcba751d84fa0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a vector.  <br /></td></tr>
<tr class="separator:a733442172fe13212fafcba751d84fa0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6470c129524e3c020e92654f2175183b" id="r_a6470c129524e3c020e92654f2175183b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a6470c129524e3c020e92654f2175183b">resize</a> (<a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> new_size, value_type const &amp;value)</td></tr>
<tr class="memdesc:a6470c129524e3c020e92654f2175183b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a vector.  <br /></td></tr>
<tr class="separator:a6470c129524e3c020e92654f2175183b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a34490b9c281548859adc63c27e4599d1" id="r_a34490b9c281548859adc63c27e4599d1"><td class="memItemLeft" align="right" valign="top"><a id="a34490b9c281548859adc63c27e4599d1" name="a34490b9c281548859adc63c27e4599d1"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>value_alignment</b> = alignof(value_type)</td></tr>
<tr class="separator:a34490b9c281548859adc63c27e4599d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a844808ecfed7019e5b29633e038235c9" id="r_a844808ecfed7019e5b29633e038235c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a844808ecfed7019e5b29633e038235c9">operator==</a> (<a class="el" href="a05732.html">lean_vector</a> const &amp;lhs, <a class="el" href="a05732.html">lean_vector</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a844808ecfed7019e5b29633e038235c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors.  <br /></td></tr>
<tr class="separator:a844808ecfed7019e5b29633e038235c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bde1614d87bd9ec5a62a343dcba729" id="r_a88bde1614d87bd9ec5a62a343dcba729"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a88bde1614d87bd9ec5a62a343dcba729">operator&lt;=&gt;</a> (<a class="el" href="a05732.html">lean_vector</a> const &amp;lhs, <a class="el" href="a05732.html">lean_vector</a> const &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a88bde1614d87bd9ec5a62a343dcba729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two vectors lexicographically.  <br /></td></tr>
<tr class="separator:a88bde1614d87bd9ec5a62a343dcba729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a781f5576bc25d9b457db9a8e754044" id="r_a6a781f5576bc25d9b457db9a8e754044"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a05732.html#a6a781f5576bc25d9b457db9a8e754044">erase</a> (<a class="el" href="a05732.html">lean_vector</a> &amp;c, value_type const &amp;value)</td></tr>
<tr class="memdesc:a6a781f5576bc25d9b457db9a8e754044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase items of a value from a vector.  <br /></td></tr>
<tr class="separator:a6a781f5576bc25d9b457db9a8e754044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9215acc703ebb85cee7d6c5789ea3a99" id="r_a9215acc703ebb85cee7d6c5789ea3a99"><td class="memTemplParams" colspan="2">template&lt;typename Pred &gt; </td></tr>
<tr class="memitem:a9215acc703ebb85cee7d6c5789ea3a99"><td class="memTemplItemLeft" align="right" valign="top"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="a05732.html#a9215acc703ebb85cee7d6c5789ea3a99">erase</a> (<a class="el" href="a05732.html">lean_vector</a> &amp;c, Pred pred)</td></tr>
<tr class="memdesc:a9215acc703ebb85cee7d6c5789ea3a99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase items of a value from a vector.  <br /></td></tr>
<tr class="separator:a9215acc703ebb85cee7d6c5789ea3a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f96d52812f9e69b1589569e57a7e0e3" id="r_a2f96d52812f9e69b1589569e57a7e0e3"><td class="memItemLeft" align="right" valign="top"><a id="a2f96d52812f9e69b1589569e57a7e0e3" name="a2f96d52812f9e69b1589569e57a7e0e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="a05732.html">lean_vector</a> &amp;lhs, <a class="el" href="a05732.html">lean_vector</a> &amp;rhs) noexcept</td></tr>
<tr class="separator:a2f96d52812f9e69b1589569e57a7e0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class hi::v1::lean_vector&lt; T &gt;</div><p>Lean-vector with (SVO) short-vector-optimization. </p>
<p>The maximum number of items in SVO are:<code>(sizeof(T *) * 3 - 1) / sizeof(T)</code> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9d4bd3e52876efbd6d0f0213a97f2ed5" name="a9d4bd3e52876efbd6d0f0213a97f2ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4bd3e52876efbd6d0f0213a97f2ed5">&#9670;&#160;</a></span>lean_vector() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::lean_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct an empty vector. </p>

</div>
</div>
<a id="ad1ba6c80fb09eee162418a255cb416de" name="ad1ba6c80fb09eee162418a255cb416de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ba6c80fb09eee162418a255cb416de">&#9670;&#160;</a></span>~lean_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::~<a class="el" href="a05732.html">lean_vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destruct the vector. </p>

</div>
</div>
<a id="a009483910d8dda316d0b17f92f4127ff" name="a009483910d8dda316d0b17f92f4127ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009483910d8dda316d0b17f92f4127ff">&#9670;&#160;</a></span>lean_vector() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::lean_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-construct a vector. </p>
<p>This will copy a vector. If the copy requires an allocation the new allocation will fit the number of items exactly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fbeb35713e1181c14ac7e6f65fe4ac4" name="a8fbeb35713e1181c14ac7e6f65fe4ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fbeb35713e1181c14ac7e6f65fe4ac4">&#9670;&#160;</a></span>lean_vector() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::lean_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-construct a vector. </p>
<p>This will steal the allocation from the other vector, or move the items if the number of items is less than or equal to <code><a class="el" href="a05732.html#a4e0ab5070a807687b4fae0bcdb6f2e99" title="The maximum number of items that can fit without allocation.">short_capacity()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8739df04d292d9ac37d0116f820619b" name="ae8739df04d292d9ac37d0116f820619b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8739df04d292d9ac37d0116f820619b">&#9670;&#160;</a></span>lean_vector() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::lean_vector </td>
          <td>(</td>
          <td class="paramtype">std::input_iterator auto&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::input_iterator auto&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with the data pointed by iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator pointing to the first item to copy. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator pointing beyond the last item to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b2346f101b5f2e30562b18db7d8777" name="a52b2346f101b5f2e30562b18db7d8777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b2346f101b5f2e30562b18db7d8777">&#9670;&#160;</a></span>lean_vector() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::lean_vector </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a vector with the given initializer list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The list of values to copy into the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af3e293c1f9ddadee630358442fba4562" name="af3e293c1f9ddadee630358442fba4562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e293c1f9ddadee630358442fba4562">&#9670;&#160;</a></span>assign() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the data in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The number of times to copy <em>value</em> into the vector. </td></tr>
    <tr><td class="paramname">value</td><td>The value to copy into the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8bc44e4ca9701edbcd442fa02fed6905" name="a8bc44e4ca9701edbcd442fa02fed6905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc44e4ca9701edbcd442fa02fed6905">&#9670;&#160;</a></span>assign() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the data in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>A list of data to copy into the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9533289ab93373e885b423c1ae8d6d20" name="a9533289ab93373e885b423c1ae8d6d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9533289ab93373e885b423c1ae8d6d20">&#9670;&#160;</a></span>assign() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">std::input_iterator auto&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::input_iterator auto&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the data in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A iterator pointing to the first value to copy. </td></tr>
    <tr><td class="paramname">last</td><td>A iterator pointing beyond the last value to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9de7d5484cc1cf92681a2d8daf8c8732" name="a9de7d5484cc1cf92681a2d8daf8c8732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9de7d5484cc1cf92681a2d8daf8c8732">&#9670;&#160;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to an item in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to the item in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the item in the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>When index points beyond the size of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf1e6bd9c0a6f4bbbedb40ddb2448674" name="aaf1e6bd9c0a6f4bbbedb40ddb2448674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1e6bd9c0a6f4bbbedb40ddb2448674">&#9670;&#160;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const-reference to an item in the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to the item in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the item in the vector. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://en.cppreference.com/w/cpp/error/out_of_range.html">std::out_of_range</a></td><td>When index points beyond the size of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5abe4f4cfa1d5f4384cf690a55e920d" name="ac5abe4f4cfa1d5f4384cf690a55e920d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5abe4f4cfa1d5f4384cf690a55e920d">&#9670;&#160;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const-reference to the last item in the vector. </p>
<dl class="section note"><dt>Note</dt><dd>It is undefined-behavior to call this function on an empty vector. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the last item in the vector. </dd></dl>

</div>
</div>
<a id="a162316a870010766a3bbbed0b321b3e5" name="a162316a870010766a3bbbed0b321b3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162316a870010766a3bbbed0b321b3e5">&#9670;&#160;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the last item in the vector. </p>
<dl class="section note"><dt>Note</dt><dd>It is undefined-behavior to call this function on an empty vector. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the last item in the vector. </dd></dl>

</div>
</div>
<a id="a91046ba0f53158a092849d2607dcfa2c" name="a91046ba0f53158a092849d2607dcfa2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91046ba0f53158a092849d2607dcfa2c">&#9670;&#160;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an const-iterator to the first item in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A const-iterator to the first item in the vector. </dd></dl>

</div>
</div>
<a id="a57b04cdb9a5a5bd228934e8a5977c4f7" name="a57b04cdb9a5a5bd228934e8a5977c4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b04cdb9a5a5bd228934e8a5977c4f7">&#9670;&#160;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator to the first item in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A iterator to the first item in the vector. </dd></dl>

</div>
</div>
<a id="a1145298f9e2f8ae3767e2ccf7d60064f" name="a1145298f9e2f8ae3767e2ccf7d60064f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1145298f9e2f8ae3767e2ccf7d60064f">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current capacity of the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of items that fit in the current allocation. </dd></dl>

</div>
</div>
<a id="a932390a29bfade9db62d5350a8c8a2b9" name="a932390a29bfade9db62d5350a8c8a2b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932390a29bfade9db62d5350a8c8a2b9">&#9670;&#160;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an const-iterator to the first item in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A const-iterator to the first item in the vector. </dd></dl>

</div>
</div>
<a id="a5759d8eee327cc5da171017f238c68ee" name="a5759d8eee327cc5da171017f238c68ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5759d8eee327cc5da171017f238c68ee">&#9670;&#160;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an const-iterator beyond the last item in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A const-iterator beyond the last item in the vector. </dd></dl>

</div>
</div>
<a id="a2dd53d32c855772af42cf88e3722b7e9" name="a2dd53d32c855772af42cf88e3722b7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dd53d32c855772af42cf88e3722b7e9">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all items from the vector. </p>
<p>The allocation of the items remains. </p>

</div>
</div>
<a id="a7056fc833183b037a15f17bfec418088" name="a7056fc833183b037a15f17bfec418088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7056fc833183b037a15f17bfec418088">&#9670;&#160;</a></span>data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_pointer <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const-pointer to the first item. </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the first item. </dd></dl>

</div>
</div>
<a id="a7556b20196154e44ff8f4e9774b68235" name="a7556b20196154e44ff8f4e9774b68235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7556b20196154e44ff8f4e9774b68235">&#9670;&#160;</a></span>data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the first item. </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the first item. </dd></dl>

</div>
</div>
<a id="abe97ac3c8c359b71eaabdb7f1bca9619" name="abe97ac3c8c359b71eaabdb7f1bca9619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe97ac3c8c359b71eaabdb7f1bca9619">&#9670;&#160;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct in-place a new item. </p>
<p>If the item is not placed at the end, the item will be moved to the correct position after it is created at the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position where the item will be created. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to pass to the constructor of the new item. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted item. </dd></dl>

</div>
</div>
<a id="a6b1e54b49f44c6d442d4880425ae68b1" name="a6b1e54b49f44c6d442d4880425ae68b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1e54b49f44c6d442d4880425ae68b1">&#9670;&#160;</a></span>emplace_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In-place construct an item at the end of the vector. </p>
<p>The item is directly constructed at the end of the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments passed to the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the newly constructed item in the vector. </dd></dl>

</div>
</div>
<a id="a8200c05b6649e8b413066a5b7ff9b358" name="a8200c05b6649e8b413066a5b7ff9b358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8200c05b6649e8b413066a5b7ff9b358">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the vector is empty. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The vector is empty. </td></tr>
    <tr><td class="paramname">false</td><td>The vector contains at least one item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b1018af99861e880ca1ab793b5e3e8e" name="a1b1018af99861e880ca1ab793b5e3e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b1018af99861e880ca1ab793b5e3e8e">&#9670;&#160;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an const-iterator beyond the last item in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A const-iterator beyond the last item in the vector. </dd></dl>

</div>
</div>
<a id="a52cadc35ba47cac083c39cd3b0ccd617" name="a52cadc35ba47cac083c39cd3b0ccd617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52cadc35ba47cac083c39cd3b0ccd617">&#9670;&#160;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator beyond the last item in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>A iterator beyond the last item in the vector. </dd></dl>

</div>
</div>
<a id="afb0183d874ede6d9768580bfc5b0d43b" name="afb0183d874ede6d9768580bfc5b0d43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0183d874ede6d9768580bfc5b0d43b">&#9670;&#160;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an items. </p>
<p>Erases an items between <em>first</em> and <em>last</em>. Items beyond the position will be moved.</p>
<p>This function will not change the allocation and iterators up to the erased items remain valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>An iterator pointing to the item to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the item after the removed items, or <a class="el" href="a05732.html#a52cadc35ba47cac083c39cd3b0ccd617" title="Get an iterator beyond the last item in the vector.">end()</a>. </dd></dl>

</div>
</div>
<a id="a5eeee9f15b3b6bc1db6b88528c87b757" name="a5eeee9f15b3b6bc1db6b88528c87b757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eeee9f15b3b6bc1db6b88528c87b757">&#9670;&#160;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase an item at position. </p>
<p>Erases an item at a position. Items beyond the position will be moved.</p>
<p>This function will not change the allocation and iterators up to the erased item remain valid.</p>
<dl class="section note"><dt>Note</dt><dd>It is undefined behavior to pass a iterator not belonging to this vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>An iterator pointing to the item to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the item after the removed item, or <a class="el" href="a05732.html#a52cadc35ba47cac083c39cd3b0ccd617" title="Get an iterator beyond the last item in the vector.">end()</a>. </dd></dl>

</div>
</div>
<a id="a0bd16d4a058ac76a96440e72cb21050f" name="a0bd16d4a058ac76a96440e72cb21050f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bd16d4a058ac76a96440e72cb21050f">&#9670;&#160;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const-reference to the first item in the vector. </p>
<dl class="section note"><dt>Note</dt><dd>It is undefined-behavior to call this function on an empty vector. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the first item in the vector. </dd></dl>

</div>
</div>
<a id="ab90888a049750ffd14d42525571423a5" name="ab90888a049750ffd14d42525571423a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90888a049750ffd14d42525571423a5">&#9670;&#160;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the first item in the vector. </p>
<dl class="section note"><dt>Note</dt><dd>It is undefined-behavior to call this function on an empty vector. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the first item in the vector. </dd></dl>

</div>
</div>
<a id="ae11d1455952e63ca2885784acbea6ccc" name="ae11d1455952e63ca2885784acbea6ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11d1455952e63ca2885784acbea6ccc">&#9670;&#160;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/allocator.html">allocator_type</a> <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The allocator_type used to allocate items. </p>

</div>
</div>
<a id="a9593ec98a4aa649967982956e76febc6" name="a9593ec98a4aa649967982956e76febc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9593ec98a4aa649967982956e76febc6">&#9670;&#160;</a></span>insert() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new item. </p>
<p>If the item is not placed at the end, the item will be moved to the correct position after it is moved to the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position where the item will be inserted. </td></tr>
    <tr><td class="paramname">count</td><td>The number of value to add. </td></tr>
    <tr><td class="paramname">value</td><td>The value to move into the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted item. </dd></dl>

</div>
</div>
<a id="a5876ab74d01fa1d04effcec8204a707d" name="a5876ab74d01fa1d04effcec8204a707d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5876ab74d01fa1d04effcec8204a707d">&#9670;&#160;</a></span>insert() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/initializer_list.html">std::initializer_list</a>&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new items. </p>
<p>If the items are not placed at the end, the items will be moved to the correct position after they have been copied to the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position where the items will be inserted. </td></tr>
    <tr><td class="paramname">list</td><td>A initializer list of items to copy into the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted item. </dd></dl>

</div>
</div>
<a id="a0114401f50630793f465463b37e375aa" name="a0114401f50630793f465463b37e375aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0114401f50630793f465463b37e375aa">&#9670;&#160;</a></span>insert() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::input_iterator auto&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::input_iterator auto&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert new items. </p>
<p>If the items are not placed at the end, the items will be moved to the correct position after they have been copied to the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position where the items will be inserted. </td></tr>
    <tr><td class="paramname">first</td><td>An iterator to the first item to copy. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator to one beyond the last item to copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted item. </dd></dl>

</div>
</div>
<a id="a84b8bf2387a41b4dc1d1ad57e61e7f34" name="a84b8bf2387a41b4dc1d1ad57e61e7f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b8bf2387a41b4dc1d1ad57e61e7f34">&#9670;&#160;</a></span>insert() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new item. </p>
<p>If the item is not placed at the end, the item will be moved to the correct position after it is moved to the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position where the item will be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>The value to move into the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted item. </dd></dl>

</div>
</div>
<a id="afb98e17fd016135d7903a583b41e7497" name="afb98e17fd016135d7903a583b41e7497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb98e17fd016135d7903a583b41e7497">&#9670;&#160;</a></span>insert() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a new item. </p>
<p>If the item is not placed at the end, the item will be moved to the correct position after it is copied to the end.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position where the item will be inserted. </td></tr>
    <tr><td class="paramname">value</td><td>The value to copy into the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to the newly inserted item. </dd></dl>

</div>
</div>
<a id="a1bfb3869e08382c52785b2c28fcb461e" name="a1bfb3869e08382c52785b2c28fcb461e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfb3869e08382c52785b2c28fcb461e">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05732.html">lean_vector</a> &amp; <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assign a vector. </p>
<p>This will swap the allocations between the current and <em>other</em> vector. Or this will destroy the items in the current vector, then copy the items from <em>other</em>, potentially reusing the current allocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to move. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf141f4612b911b62e52aee94683b27e" name="aaf141f4612b911b62e52aee94683b27e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf141f4612b911b62e52aee94683b27e">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a05732.html">lean_vector</a> &amp; <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assign a vector. </p>
<p>This will destroy the items in the current vector, then copy the items from <em>other</em>, potentially reusing the current allocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The vector to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b10ca7e1bc4fb38d57d30a1157a8a87" name="a9b10ca7e1bc4fb38d57d30a1157a8a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b10ca7e1bc4fb38d57d30a1157a8a87">&#9670;&#160;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const-reference to an item in the vector. </p>
<dl class="section note"><dt>Note</dt><dd>It is undefined-behavior if the index is beyond the size of the vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to the item in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the item in the vector. </dd></dl>

</div>
</div>
<a id="af5d205d7ee1752a2556c3b2e09caee78" name="af5d205d7ee1752a2556c3b2e09caee78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d205d7ee1752a2556c3b2e09caee78">&#9670;&#160;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to an item in the vector. </p>
<dl class="section note"><dt>Note</dt><dd>It is undefined-behavior if the index is beyond the size of the vector. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index to the item in the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the item in the vector. </dd></dl>

</div>
</div>
<a id="aa8683ca629dbf6340ccf6275ec7b2c5c" name="aa8683ca629dbf6340ccf6275ec7b2c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8683ca629dbf6340ccf6275ec7b2c5c">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the last item from the vector. </p>
<p>This function destroys the last item from the vector.</p>
<dl class="section note"><dt>Note</dt><dd>It is undefined behavior to call this function on an empty vector. </dd></dl>

</div>
</div>
<a id="a1645f5b2d3e045b6fbb1154398f0ebc2" name="a1645f5b2d3e045b6fbb1154398f0ebc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1645f5b2d3e045b6fbb1154398f0ebc2">&#9670;&#160;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move an item to the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to move to the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fafda4b07aab202d15218ee0288774d" name="a2fafda4b07aab202d15218ee0288774d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fafda4b07aab202d15218ee0288774d">&#9670;&#160;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an item to the end of the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to copy to the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb7299d1c263daa1e7e9d65af6762187" name="afb7299d1c263daa1e7e9d65af6762187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7299d1c263daa1e7e9d65af6762187">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>new_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reserve capacity for items. </p>
<p>This will create a new allocation when <em>new_capacity</em> is larger than the current capacity and move the items from the previous allocation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_capacity</td><td>The new capacity that the vector should take. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op when the <em>new_capacity</em> is smaller than the current capacity. </dd></dl>

</div>
</div>
<a id="a733442172fe13212fafcba751d84fa0a" name="a733442172fe13212fafcba751d84fa0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733442172fe13212fafcba751d84fa0a">&#9670;&#160;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize a vector. </p>
<p>When the <em>new_size</em> is larger than the current size a new allocation may be created and the new-items beyond the old size are default constructed.</p>
<p>When the <em>new_size</em> is smaller than the current size the allocation remains and the old-items beyond <em>new_size</em> are destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>The new size of the vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6470c129524e3c020e92654f2175183b" name="a6470c129524e3c020e92654f2175183b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6470c129524e3c020e92654f2175183b">&#9670;&#160;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a>&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize a vector. </p>
<p>When the <em>new_size</em> is larger than the current size a new allocation may be created and the new-items beyond the old size are copied from <em>value</em>.</p>
<p>When the <em>new_size</em> is smaller than the current size the allocation remains and the old-items beyond <em>new_size</em> are destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>The new size of the vector. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the items being optionally created. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e0ab5070a807687b4fae0bcdb6f2e99" name="a4e0ab5070a807687b4fae0bcdb6f2e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e0ab5070a807687b4fae0bcdb6f2e99">&#9670;&#160;</a></span>short_capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::short_capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The maximum number of items that can fit without allocation. </p>

</div>
</div>
<a id="aa32620dff1ab4a3eef6c0c54b8afcdea" name="aa32620dff1ab4a3eef6c0c54b8afcdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32620dff1ab4a3eef6c0c54b8afcdea">&#9670;&#160;</a></span>shrink_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrink the allocation to fit the current number of items. </p>
<p>If the current allocation is larger than the number of items in the vector, then a new allocation is created to exactly fit the number of items and the items are moved to the new allocation.</p>
<dl class="section note"><dt>Note</dt><dd>This function is a no-op if the current allocation is the same as the number of items. </dd></dl>

</div>
</div>
<a id="a9fc78141ebcf5b628c213a15265d3dc4" name="a9fc78141ebcf5b628c213a15265d3dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc78141ebcf5b628c213a15265d3dc4">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> <a class="el" href="a05732.html">hi::v1::lean_vector</a>&lt; T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items in the vector. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of items in the vector. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Symbol Documentation</h2>
<a id="a9215acc703ebb85cee7d6c5789ea3a99" name="a9215acc703ebb85cee7d6c5789ea3a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9215acc703ebb85cee7d6c5789ea3a99">&#9670;&#160;</a></span>erase <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Pred &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase items of a value from a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The vector with items </td></tr>
    <tr><td class="paramname">pred</td><td>A predicate function of the form <code>bool(value_type const &amp;)</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items removed. </dd></dl>

</div>
</div>
<a id="a6a781f5576bc25d9b457db9a8e754044" name="a6a781f5576bc25d9b457db9a8e754044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a781f5576bc25d9b457db9a8e754044">&#9670;&#160;</a></span>erase <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">size_type</a> erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type const &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase items of a value from a vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>The vector with items </td></tr>
    <tr><td class="paramname">value</td><td>The value to remove from the vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of items removed. </dd></dl>

</div>
</div>
<a id="a88bde1614d87bd9ec5a62a343dcba729" name="a88bde1614d87bd9ec5a62a343dcba729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bde1614d87bd9ec5a62a343dcba729">&#9670;&#160;</a></span>operator&lt;=&gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto operator&lt;=&gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two vectors lexicographically. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand-side vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand-side vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The three-way result of the lexicographical compare. </dd></dl>

</div>
</div>
<a id="a844808ecfed7019e5b29633e038235c9" name="a844808ecfed7019e5b29633e038235c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a844808ecfed7019e5b29633e038235c9">&#9670;&#160;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a05732.html">lean_vector</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare two vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand-side vector. </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand-side vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If both vectors contain the same items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>hikogui/src/hikogui/<a class="el" href="a02156_source.html">lean_vector.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.9.8-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 29 2023 19:33:32 for HikoGUI by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
<script>
mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    themeVariables: {
    primaryColor: '#f4f4ff',
    secondaryColor: 'rgba(244,244,255,0.9)',
    tertiaryColor: '#F9FAFC',
    },
});
</script>
</body>
</html>
</html>