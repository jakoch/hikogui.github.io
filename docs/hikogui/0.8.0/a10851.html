<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HikoGUI: How to make widgets</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="version_dropdown.js"></script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">HikoGUI
   </div>
   <div id="projectbrief">A low latency retained GUI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">How to make widgets</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md122"></a>
Visual</h1>
<p>A widget is rendered in three steps:</p>
<ol type="1">
<li><code>widget::set_constraints()</code> is called to determine the minimum, preferred &amp; maximum size and margin of the widget.</li>
<li><code>widget::set_layout()</code> is called to set the size and coordinate-transformations for the widget.</li>
<li><code>widget::draw()</code> is called to (partially) draw the widget.</li>
</ol>
<p>Each of the three steps is optional, with increasing order of likeliness to be called on each vertical-sync.</p>
<h2><a class="anchor" id="autotoc_md123"></a>
Constraints</h2>
<p>When the window is first opened or when a widget requests a reconstrain; all the widgets are requested to give their size and other attributes needed for laying-out the widgets.</p>
<p>Currently, the constrain attributes are:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">attribute   </th><th class="markdownTableHeadLeft">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>minimum</code>   </td><td class="markdownTableBodyLeft">The absolute minimum size the widget MUST be laid out as.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>preferred</code>   </td><td class="markdownTableBodyLeft">The preferred size the widget CAN be laid out as.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>maximum</code>   </td><td class="markdownTableBodyLeft">The maximum size the widget SHOULD be laid out as.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>margin</code>   </td><td class="markdownTableBodyLeft">The minimum margin to other sibling widgets or parent's edge.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>baseline</code>   </td><td class="markdownTableBodyLeft">How to calculate the base-line of the text in this widget.   </td></tr>
</table>
<p>To calculate the constraints of a widget, potentially expensive calculations may need to be performed, such as loading glyph metrics and doing initial text shaping to determine the size of a label. It is recommended to store these calculations in member variables of your custom widget. Note: In the example below, <code>_layout</code> is reset so that calculations that depend on these member variables are triggered inside <code>set_layout()</code>.</p>
<p>Therefor it is recommended to not request a reconstrain, unless the widget is expecting it's constraints to change, such as when the text in the label changes.</p>
<p>The following is an example of <code>set_constraints()</code> function for a widget with a label-child. You can see that the constraints are based on the constraints of the label combined with sizes taken from the theme. The label widget itself is based on <code>theme().size()</code> and the width of the text.</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="a05659.html">hi::box_constraints</a> <span class="keyword">const</span> &amp;set_constraints(set_constraints_context <span class="keyword">const</span> &amp;context) <span class="keyword">noexcept</span> <span class="keyword">override</span></div>
<div class="line">{</div>
<div class="line">    _layout = {};</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> label_constraints = _label_widget-&gt;set_constraints(context);</div>
<div class="line">    _constraints.minimum = label_constraints.minimum;</div>
<div class="line">    _constraints.preferred = label_constraints.preferred + theme().margin();</div>
<div class="line">    _constraints.maximum = label_constraints.maximum + <a class="code hl_class" href="a05099.html">hi::extent2</a>{100.0f, 50.0f};</div>
<div class="line">    _constraints.margin = theme().margin();</div>
<div class="line">    _constraints.baseline = label_constraints.baseline;</div>
<div class="line">    <span class="keywordflow">return</span> _constraints;</div>
<div class="line">}</div>
<div class="ttc" id="aa05099_html"><div class="ttname"><a href="a05099.html">hi::extent2</a></div><div class="ttdoc">A high-level geometric extent.</div><div class="ttdef"><b>Definition</b> extent2.hpp:29</div></div>
<div class="ttc" id="aa05659_html"><div class="ttname"><a href="a05659.html">hi::box_constraints</a></div><div class="ttdoc">2D constraints.</div><div class="ttdef"><b>Definition</b> box_constraints.hpp:25</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md124"></a>
Layout</h2>
<p>After constraining or when a widget request a relayout; all widgets are laid out by their parents, based on the previous information gathered during constraining.</p>
<p>A <code>widget_layout</code> currently consists of the following attributes:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">attribute   </th><th class="markdownTableHeadLeft">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>size</code>   </td><td class="markdownTableBodyLeft">The size of the widget.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>to_parent</code>   </td><td class="markdownTableBodyLeft">Transformation matrix to convert coordinates from local to parent.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>from_parent</code>   </td><td class="markdownTableBodyLeft">Transformation matrix to convert coordinates from parent to local.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>to_window</code>   </td><td class="markdownTableBodyLeft">Transformation matrix to convert coordinates from local to window.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>from_window</code>   </td><td class="markdownTableBodyLeft">Transformation matrix to convert coordinates from window to local.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>clipping_rectangle</code>   </td><td class="markdownTableBodyLeft">The axis aligned rectangle to clip any drawing.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>display_time_point</code>   </td><td class="markdownTableBodyLeft">The time when the drawing will appear on the screen.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>baseline</code>   </td><td class="markdownTableBodyLeft">The y-axis position of the baseline for text in this widget.   </td></tr>
</table>
<p>A layout can be transformed to child size &amp; coordinates, by combining the layout with a rectangle in local coordinate space and an elevation. In most cases, the elevation increment should be 1 (default). The elevation increment for overlay widgets should be 25.</p>
<p>To reduce the complexities of the <code>set_layout()</code> and <code>draw()</code> functions, the <code>size</code> of the layout MUST be at least the size of the <code>minimum</code> constraint. Otherwise, it is possible for calculations to underflow. Breaching the <code>maximum</code> constraint is less problematic for these calculations and is allowed and expected to happen.</p>
<p>In the example below, the <code>_layout</code> of the widget is updated by the <code>context</code> argument. If the size was changed during the update, then a new <code>_label_rectangle</code> is calculated, in the widget's local coordinate system.</p>
<p>The child widget's <code>set_layout()</code> must be called even if the size has not changed, as the widget may have been moved, which is captured in the layout as well. As you can see, the layout that is passed to the child is calculated by transforming the context by the <code>_label_rectangle</code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> set_layout(<a class="code hl_class" href="a05487.html">hi::widget_layout</a> <span class="keyword">const</span> &amp;layout) <span class="keyword">noexcept</span> <span class="keyword">override</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (compare_store(_layout, context)) {</div>
<div class="line">        _label_rectangle = align(layout.rectangle(), _label_widget-&gt;update_constraints().preferred, hi::alignment::middle_center);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    _label_widget-&gt;set_layout(_label_rectangle * layout);</div>
<div class="line">}</div>
<div class="ttc" id="aa05487_html"><div class="ttname"><a href="a05487.html">hi::widget_layout</a></div><div class="ttdoc">The layout of a widget.</div><div class="ttdef"><b>Definition</b> widget_layout.hpp:38</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md125"></a>
Drawing</h2>
<p>This is an introduction to drawing.</p>
<p>You can find more information in the <a class="el" href="a10849.html">how to draw</a> document.</p>
<p>The draw context has the following attributes:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">attribute   </th><th class="markdownTableHeadLeft">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft"><code>scissor_rectangle</code>   </td><td class="markdownTableBodyLeft">The rectangle that is being drawn on the frame buffer.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"><code>display_time_point</code>   </td><td class="markdownTableBodyLeft">The time when the drawing will appear on the screen.   </td></tr>
</table>
<p>The <code>scissor_rectangle</code> is used to only update the region of the window that needs to be redrawn. When a widget calls the <code>request_redraw()</code> then the rectangle is merged with the window's redraw-rectangle, and on the next frame, the <code>scissor_rectangle</code> is calculated to include the current redraw-rectangle. It is allowed to draw outside the <code>scissor_rectangle</code>, but this will not be visible.</p>
<p>The <code>display_time_point</code> includes the delays in the swap-chain for double or triple buffering and processing delays in the display device when supported by the operating system.</p>
<p>The <code>draw_context::draw_*()</code> methods all accept the layout as the first argument, this allows the other arguments to the draw function to be in the local coordinate system. In certain cases, a widget may want to make a copy of the layout to temporarily change the clipping rectangle.</p>
<p>In the example below, you can see that only when a widget is visible should the widget and its children be drawn. The <code>overlap()</code> check compared the context's <code>scissor_rectangle</code> with the layout's <code>redraw_rectangle</code> only when they partially or fully overlap should a widget draw its internals.</p>
<p>As you can see, many values for the draw calls come from values taken from the current theme, and from the context-sensitive colors, which are based on the current theme's colors and may change based on the state of the widget, like: keyboard focus, window active &amp; mouse hover.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> draw(<a class="code hl_class" href="a05251.html">hi::draw_context</a> <span class="keyword">const</span> &amp;context) <span class="keyword">noexcept</span> <span class="keyword">override</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (*mode &gt; hi::widget_mode::invisible) {</div>
<div class="line">        <span class="keywordflow">if</span> (overlaps(context, layout())) {</div>
<div class="line">            context.draw_box(</div>
<div class="line">                _layout,</div>
<div class="line">                _layout.rectangle(),</div>
<div class="line">                background_color(),</div>
<div class="line">                foreground_color(),</div>
<div class="line">                theme().border_width(),</div>
<div class="line">                hi::border_side::outside,</div>
<div class="line">                theme().rounding_radius());</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        _label_widget-&gt;draw(context);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aa05251_html"><div class="ttname"><a href="a05251.html">hi::draw_context</a></div><div class="ttdoc">Draw context for drawing using the HikoGUI shaders.</div><div class="ttdef"><b>Definition</b> draw_context.hpp:208</div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md126"></a>
Hitbox check</h1>
<p>When you want your widget to receive mouse events, you will first need to override the <code>widget::hitbox_test()</code> function. This function is called by the operating system to determine the type of cursor and if the window can be dragged or resized at that position.</p>
<p>Hikogui at the same time uses this function to determine if this widget is directly underneath the mouse cursor; at the highest elevation. It will then send mouse events directly to the widget, and continue to track drag and exit events when the mouse leaves the widget.</p>
<p>The default <code>hitbox_test()</code> returns an empty <code>hitbox</code>, this means that the mouse pointer is not hitting the widget, or the widget does not receive any mouse events at this time.</p>
<p>To handle situations where your widget is scrolled outside a scroll view's aperture you should always use the <code>layout().constrains(position)</code> test which also checks the clipping rectangle.</p>
<p>You can call <code>widget::hitbox_test_from_parent()</code> on any of the widget's children that can be interacted with. The <code>hitbox_test_from_parent()</code> will adjust the given position to the local coordinate system of the child widget. You can also use this function to combine the <code>hitbox</code> results from several children.</p>
<div class="fragment"><div class="line">[[nodiscard]] hi::hitbox hitbox_test(hi::point3 position) <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (*mode &gt;= hi::widget_mode::partial and layout().contains(position)) {</div>
<div class="line">        <span class="keywordflow">return</span> {id, position, hi::hitbox::Type::Button};</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md127"></a>
Accepting keyboard focus</h1>
<p>Similar to how <code>hitbox_test</code> will enable receiving mouse events for the widget, overriding <code>widget::accepts_keyboard_focus()</code> will enable receiving keyboard events for the widget.</p>
<p>The <code>group</code> argument is a mask of reasons why this widget is being focused:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">name   </th><th class="markdownTableHeadLeft">description    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">normal   </td><td class="markdownTableBodyLeft">The user used (shift-) tab to select the next normal widget.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">menu   </td><td class="markdownTableBodyLeft">The user used up/down-arrow to select the next widget in a pull down menu.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">toolbar   </td><td class="markdownTableBodyLeft">The user used alt or left/right-arrow to select the next widget in the toolbar.   </td></tr>
</table>
<p>A mouse click on a widget will cause <code>accepts_keyboard_focus()</code> to be called with all three values set. This means that any widget that will accept focus from any of those in the table above will also accept keyboard focus by a mouse click.</p>
<div class="fragment"><div class="line">[[nodiscard]] <span class="keywordtype">bool</span> accepts_keyboard_focus(hi::keyboard_focus_group group) <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> *mode &gt;= hi::widget_mode::partial and is_normal(group);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md128"></a>
Event handling</h1>
<p>An event is often generated by the operating system for mouse, keyboard and other human interface devices (HID).</p>
<p>Here are the steps of how an event travels through the system:</p><ol type="1">
<li>An event is generated and send to the window's <code>gui_window::process_event()</code>.</li>
<li>A target-widget is determined from the event and the current state of the window.</li>
<li>If the target-widget is different from the previous event, then exit-, enter- and cancel-events are send to the appropriate widgets.</li>
<li>The event is translated into a bundle of events by the key-binding system. The bundle of events includes the original event and the translated events in order of priority.</li>
<li>For each of the events in the bundle <code>widget::handle_event()</code> is called on the target-widget, then the same for the parent- and each ancestor-widget. Processing will stop as soon as <code>widget::handle_event()</code> returns <code>true</code>.</li>
</ol>
<h2><a class="anchor" id="autotoc_md129"></a>
Handling keyboard events</h2>
<p>There are several different events for handling keyboards:</p><ul>
<li><code>keyboard_enter</code>: The widget receiving this got keyboard focus.</li>
<li><code>keyboard_exit</code>: The widget receiving this lost keyboard focus.</li>
<li><code>keyboard_down</code>: A key was pressed.</li>
<li><code>keyboard_up</code>: A key was released.</li>
<li><code>keyboard_grapheme</code>: A key press was translated to a unicode-grapheme-cluster.</li>
<li><code>keyboard_partial_grapheme</code>: A key press causes a grapheme compositing action and this is the partially constructed grapheme to display.</li>
</ul>
<p>The <code>keyboard_down</code> event is a candidate automatically generate a bundle of events using the key-bindings.</p>
<p>In this example, the widget intercepts a grapheme being entered on the keyboard. Graphemes are what a user of a language preceives what a single character is, this may be one or more unicode code-points where accents are composed on top of a base character. The function returns <code>true</code> to signify that it handled the event and that further processing of the bundle of events should stop.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> handle_event(<a class="code hl_class" href="a05423.html">hi::gui_event</a> <span class="keyword">const</span>&amp; event) <span class="keyword">noexcept</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (event.type()) {</div>
<div class="line">    <span class="keywordflow">case</span> hi::gui_event_type::keyboard_grapheme:</div>
<div class="line">        <span class="keywordflow">if</span> (*mode &gt;= hi::widget_mode::partial) {</div>
<div class="line">            hi_log_info(<span class="stringliteral">&quot;User typed the letter U+{:x}.&quot;</span>, <span class="keyword">static_cast&lt;</span>uint32_t<span class="keyword">&gt;</span>(event.grapheme().front()));</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    <span class="keywordflow">default</span>:;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> super::handle_event(event);;</div>
<div class="line">}</div>
<div class="ttc" id="aa05423_html"><div class="ttname"><a href="a05423.html">hi::gui_event</a></div><div class="ttdoc">A user interface event.</div><div class="ttdef"><b>Definition</b> gui_event.hpp:75</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md130"></a>
Handling mouse events</h2>
<p>There are several different events for handling mouse:</p><ul>
<li><code>mouse_enter</code>: The mouse cursor has entered the widget that received this event.</li>
<li><code>mouse_exit</code>: The mouse cursor has left the widget that received this event, unless dragging.</li>
<li><code>mouse_down</code>: A mouse button was pressed.</li>
<li><code>mouse_up</code>: A mouse button was released.</li>
<li><code>mouse_move</code>: The mouse cursor has moved within the widget receiving this event.</li>
<li><code>mouse_drag</code>: While a mouse button is pressed the mouse cursor has moved, only the widget where the drag was started receives this event.</li>
<li><code>mouse_wheel</code>: The mouse's wheel has turned in either both x- or y-axis while the mouse cursor is over the widget.</li>
</ul>
<p><code>mouse_down</code> events may also be translated into a bundle of events using the keyboard-bindings system. This allows the user to select which button is used for what purpose, including left/right handed.</p>
<p>During the drag events:</p><ul>
<li>The widget where the drag starts will receive all mouse events.</li>
<li>Drag events continue even if the mouse leaves the window.</li>
<li>No <code>mouse_exit</code> or <code>mouse_enter</code> events are send to any widget.</li>
<li>When the drag ends, the widget where the drag starts receives the <code>mouse_up</code> event.</li>
<li>If the mouse was hovering over another widget or outside the window when the drag ends, the <code>mouse_up</code> event is followed by the appropriate <code>mouse_exit</code> and <code>mouse_enter</code> events.</li>
</ul>
<p>The function below intercepts the left-mouse-button-up event when the mouse is inside the rectangle of the widget, this allows a drag outside the widget to cancel an accidental button-down. The function then forwards this event as a <code>gui_activate</code> command which is the same command that is being send when pressing the space-bar.</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> handle_event(<a class="code hl_class" href="a05423.html">hi::gui_event</a> <span class="keyword">const</span>&amp; event) <span class="keyword">noexcept</span> <span class="keyword">override</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (event.type()) {</div>
<div class="line">    <span class="keywordflow">case</span> hi::gui_event_type::mouse_down:</div>
<div class="line">        <span class="keywordflow">if</span> (*mode &gt;= hi::widget_mode::partial and event.mouse().cause.left_button) {</div>
<div class="line">            hi_log_info(<span class="stringliteral">&quot;Mouse was clicked {} times in a row&quot;</span>, event.mouse().click_count);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> super::handle_event(event);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md131"></a>
Handling command events</h2>
<p>It is best to do actual work in the command event handler. This allows the user to customize what key and mouse-button combinations causes which commands to be send. The key and mouse-button combination to command translations are stored in the <code>*.keybinds.json</code> files.</p>
<p>Here are several example command events:</p><ul>
<li><code>gui_cancel</code>: The widget should cancel the current incomplete operation.</li>
<li><code>gui_activate</code>: Often the left-mouse-button, and spacebar are bound to this event. It should perform the standard action on the widget.</li>
<li><code>gui_activate_next</code>: Often the enter-key are bound to this event, which should It should perform the standard action on the widget, followed by changing the keyboard focus to the next widget.</li>
<li><code>gui_*</code>: Other gui commands, including those for navigating between widgets.</li>
<li><code>text_*</code>: Commands having to do with navigating and editing text.</li>
<li><code>file_*</code>: Commands for loading, saving files.</li>
</ul>
<p>In the example below the widget listens to <code>gui_activate</code>:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> handle_event(<a class="code hl_class" href="a05423.html">hi::gui_event</a> <span class="keyword">const</span>&amp; event) <span class="keyword">noexcept</span> <span class="keyword">override</span></div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (event.type()) {</div>
<div class="line">    <span class="keywordflow">case</span> hi::gui_event_type::gui_activate:</div>
<div class="line">        <span class="keywordflow">if</span> (*mode &gt;= widget_mode::partial) {</div>
<div class="line">            value = not *value;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">default</span>:;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> super::handle_event(event);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md132"></a>
Children</h1>
<p>For the following high-performance methods the children need to be recursively called:</p>
<ul>
<li><code>set_contraints()</code></li>
<li><code>set_layout()</code></li>
<li><code>draw()</code></li>
<li><code>hitbox_test()</code></li>
</ul>
<p>A widget that owns one or more child widgets will need to override the <code>children()</code> method to let the system know how to call the lower-performance methods automatically. The <code>children()</code> method should be implemented as a generator-coroutine, which <code>co_yield</code> the raw-pointer to each widget.</p>
<p>The keyboard focus ordering is the same as the order of children yielded by this function.</p>
<p>The example function below yields the pointer to both children stored as member variables and children stored in a vector.</p>
<div class="fragment"><div class="line">[[nodiscard]] <a class="code hl_function" href="a02246.html#ae79c0c942846b177e441c19f754336df">hi::generator&lt;widget_intf const &amp;&gt;</a> children(<span class="keywordtype">bool</span> include_invisible) <span class="keyword">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span></div>
<div class="line">{</div>
<div class="line">    <span class="keyword">co_yield</span> _label_widget.get();</div>
<div class="line">    <span class="keyword">co_yield</span> _checkbox_widget.get();</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp;child: _children) {</div>
<div class="line">        <span class="keyword">co_yield</span> child.get();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aa02246_html_ae79c0c942846b177e441c19f754336df"><div class="ttname"><a href="a02246.html#ae79c0c942846b177e441c19f754336df">hi::v1::narrow_cast</a></div><div class="ttdeci">constexpr Out narrow_cast(In const &amp;rhs) noexcept</div><div class="ttdoc">Cast numeric values without loss of precision.</div><div class="ttdef"><b>Definition</b> cast.hpp:377</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md133"></a>
Baseline</h2>
<p>Widgets that appear next to each other should share a baseline so that their text will be properly aligned.</p>
<p>Widgets communicate the desire of where it wants the baseline to be through the <code>set_contraints()</code> method. This includes a priority so that different types of widget are able to size and position correctly.</p>
<p>During <code>set_layout()</code> the actual baseline that is shared between widgets is communicated to each widget. In many cases the baseline is just forwarded to the child widget, otherwise the baseline is modified through the <code>widget_layout::transform()</code>.</p>
<p>If you want a child widget to have their own natural baseline, you can simply call the <code>widget_layout::transform()</code> with the child's <code>update_constraints().baseline</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.9.8-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Sep 29 2023 19:34:31 for HikoGUI by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
<script>
mermaid.initialize({
    startOnLoad: true,
    theme: 'base',
    themeVariables: {
    primaryColor: '#f4f4ff',
    secondaryColor: 'rgba(244,244,255,0.9)',
    tertiaryColor: '#F9FAFC',
    },
});
</script>
</body>
</html>
</html>